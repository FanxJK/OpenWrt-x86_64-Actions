#
# This workflow builds ImmortalWrt firmware using the official Image Builder.
# It determines the latest release tag from the ImmortalWrt repository based on
# the configured BUILD_VER prefix (e.g. 24.10) and then downloads the matching
# Image Builder tarball for the x86/64 target.  The workflow parses the
# provided .config to generate a package list and uses the Image Builder to
# assemble a custom firmware image without compiling the entire source tree.
# This reduces build time and CPU usage significantly compared to a full
# toolchain build.

name: Build OpenWrt

on:
  repository_dispatch:
  workflow_dispatch:

env:
  # Upstream repository and version prefix.  BUILD_VER is used to
  # select the most recent tag that begins with this value, e.g. v24.10.2.
  REPO_NAME: immortalwrt/immortalwrt
  BUILD_VER: "24.10"
  FEEDS_CONF: feeds.conf.default
  CONFIG_FILE: .config
  DIY_P1_SH: diy-part1.sh
  DIY_P2_SH: diy-part2.sh
  UPLOAD_BIN_DIR: false
  UPLOAD_FIRMWARE: true
  UPLOAD_RELEASE: true
  # Use the Asia/Shanghai timezone by default; adjust as necessary.
  TZ: Asia/Shanghai
  # Target architecture for Image Builder.  We build x86/64 firmware here.
  TARGET_ARCH: "x86/64"

jobs:
  build:
    runs-on: ubuntu-22.04
    permissions:
      actions: write
      contents: write

    steps:
      - name: Initialization environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo rm -rf /etc/apt/sources.list.d/* /usr/share/dotnet /usr/local/lib/android /etc/mysql /etc/php /opt/ghc /opt/hostedtoolcache/CodeQL
          sudo rm -rf /usr/local/share/boost /usr/local/graalvm /usr/local/share/powershell /usr/local/share/chromium
          sudo rm -rf /usr/local/lib/node_modules /opt/az /opt/microsoft /usr/share/swift
          sudo docker image prune --all --force
          sudo apt-get clean
          sudo -E apt-get -qq update
          sudo -E apt-get -qq install ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
            bzip2 ccache clang cmake cpio curl device-tree-compiler ecj fastjar flex gawk gettext gcc-multilib \
            g++-multilib git gnutls-dev gperf haveged help2man intltool lib32gcc-s1 libc6-dev-i386 libelf-dev \
            libglib2.0-dev libgmp3-dev libltdl-dev libmpc-dev libmpfr-dev libncurses5-dev libncursesw5 \
            libncursesw5-dev libpython3-dev libreadline-dev libssl-dev libtool lld llvm lrzsz mkisofs msmtp \
            nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pip python3-ply \
            python3-docutils python3-pyelftools qemu-utils re2c rsync scons squashfs-tools subversion swig \
            texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
          sudo timedatectl set-timezone "$TZ"
          sudo mkdir -p /workdir
          sudo chown $USER:$GROUPS /workdir

      - name: Checkout repository
        uses: actions/checkout@v4
      # Step 1: determine the latest tag matching BUILD_VER.  Use a
      # personal access token if available to avoid rate limits.  Store
      # the result in the GitHub Actions environment.
      - name: Determine latest release tag
        working-directory: /workdir
        # Use a personal access token if provided to avoid hitting the GitHub API
        # unauthenticated rate limits.  Do not override GITHUB_TOKEN used by
        # the release step; instead use API_TOKEN for the API call.
        env:
          API_TOKEN: ${{ secrets.MY_SECRETS_TOKEN }}
        run: |
          set -eo pipefail
          echo "Fetching tags from ${REPO_NAME} matching ${BUILD_VER}"
          # Request the list of tags and filter by BUILD_VER.  We expect tags
          # like v24.10.2; removing the 'v' happens later when downloading
          # the image builder.  Authentication prevents API rate limiting.
          REPO_TAG=$(curl -H "Authorization: Bearer ${API_TOKEN}" -sX GET \
            "https://api.github.com/repos/${REPO_NAME}/tags" \
            | awk -F'"' '/"name":/ {print $4}' \
            | grep "${BUILD_VER}" \
            | head -n 1)
          if [ -z "$REPO_TAG" ]; then
            echo "No tag matching ${BUILD_VER} found" >&2
            exit 1
          fi
          echo "Found tag: $REPO_TAG"
          echo "REPO_TAG=$REPO_TAG" >> $GITHUB_ENV

      # Step 2: clone the selected ImmortalWrt tag.  Keep depth 1 to reduce
      # download size.  Symbolically link the source into the workspace.
      - name: Clone source code
        working-directory: /workdir
        run: |
          set -eo pipefail
          REPO_URL="https://github.com/${REPO_NAME}.git"
          git clone --depth=1 --branch "$REPO_TAG" "$REPO_URL" openwrt
          ln -sf /workdir/openwrt "$GITHUB_WORKSPACE/openwrt"

      # Step 3: replace feeds.conf, run DIY part1 and update feeds
      # Step 3a: replace feeds configuration and run DIY part1
      - name: Replace feeds config and run DIY part1
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          # Replace feeds.conf.default if a custom feeds config exists in the root of the repository
          if [ -e "$GITHUB_WORKSPACE/$FEEDS_CONF" ]; then
            echo "Replacing feeds.conf.default with $FEEDS_CONF"
            mv "$GITHUB_WORKSPACE/$FEEDS_CONF" ./feeds.conf.default
          fi
          # Execute diy-part1.sh if present; ignore errors so the build does not fail prematurely
          if [ -f "$GITHUB_WORKSPACE/$DIY_P1_SH" ]; then
            echo "Executing DIY part1 script"
            chmod +x "$GITHUB_WORKSPACE/$DIY_P1_SH"
            "$GITHUB_WORKSPACE/$DIY_P1_SH" || true
          fi

      # Step 3b: update and install feeds
      - name: Update and install feeds
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          echo "Updating all feeds"
          ./scripts/feeds update -a
          echo "Installing feeds (pass 1)"
          ./scripts/feeds install -a
          echo "Installing feeds (pass 2)"
          ./scripts/feeds install -a

      # Step 4a: copy custom files and configuration
      - name: Copy custom files and configuration
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          # Copy overlay files (the 'files' directory) if it exists in the repository
          if [ -d "$GITHUB_WORKSPACE/files" ]; then
            echo "Copying custom overlay files"
            cp -r "$GITHUB_WORKSPACE/files" ./files
          fi
          # Copy the provided .config if present to override default config
          if [ -e "$GITHUB_WORKSPACE/$CONFIG_FILE" ]; then
            echo "Using custom .config"
            cp "$GITHUB_WORKSPACE/$CONFIG_FILE" ./.config
          fi

      # Step 4b: run DIY part2 script
      - name: Run DIY part2 script
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          if [ -f "$GITHUB_WORKSPACE/$DIY_P2_SH" ]; then
            echo "Executing DIY part2 script"
            chmod +x "$GITHUB_WORKSPACE/$DIY_P2_SH"
            "$GITHUB_WORKSPACE/$DIY_P2_SH" || true
          fi

      # Step 4c: normalize configuration (defconfig)
      - name: Run defconfig
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          echo "Running make defconfig"
          make defconfig

      # Step 4d: generate package list from .config
      - name: Generate package list
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          echo "Extracting package list from .config"
          PACKAGE_LIST=$(grep '^CONFIG_PACKAGE_' .config | grep '=y' \
            | sed -e 's/CONFIG_PACKAGE_//' -e 's/=y//' \
            | tr '\n' ' ' | sed -e 's/[[:space:]]\{1,\}/ /g')
          echo "PACKAGE_LIST=${PACKAGE_LIST}" >> $GITHUB_ENV
          echo "Generated package list: ${PACKAGE_LIST}"

      # Step 5: set release tag and write version information for the firmware
      - name: Set release tag and prepare version file
        working-directory: /workdir/openwrt
        run: |
          set -eo pipefail
          BUILD_DATE=$(date +"%Y.%m.%d")
          # Persist release tag for later steps and release creation
          echo "RELEASE_TAG=${REPO_TAG}-${BUILD_DATE}" >> $GITHUB_ENV
          # Create or update the overlay version file.  When using the Image Builder,
          # files placed under the 'files' directory are injected into the root
          # filesystem.  Store the DISTRIB_GITHUBVER in etc/openwrt_release so
          # the firmware identifies itself with the tag and build date.
          mkdir -p files/etc
          echo "DISTRIB_GITHUBVER='${REPO_TAG}-${BUILD_DATE}'" > files/etc/openwrt_release

      - name: Download and extract Image Builder
        working-directory: /workdir
        run: |
          set -eo pipefail
          RELEASE_VERSION="${REPO_TAG#v}"
          IB_FILE="immortalwrt-imagebuilder-${RELEASE_VERSION}-x86-64.Linux-x86_64.tar.zst"
          DOWNLOAD_URL="https://downloads.immortalwrt.org/releases/${RELEASE_VERSION}/targets/x86/64/${IB_FILE}"
          echo "Downloading Image Builder from $DOWNLOAD_URL"
          curl -L --fail -o "$IB_FILE" "$DOWNLOAD_URL"
          # Extract using zstd compression support.  The tar file unpacks to a
          # directory named after the archive without the .tar.zst extension.
          tar -I zstd -xf "$IB_FILE"
          # Normalize the extracted directory name.  The name matches the
          # archive without extension; move it to a generic name for ease of use.
          mv "immortalwrt-imagebuilder-${RELEASE_VERSION}-x86-64.Linux-x86_64" imagebuilder

      - name: Build firmware using Image Builder
        working-directory: /workdir/imagebuilder
        run: |
          set -eo pipefail
          # Copy overlay files into the Image Builder.  The 'files' directory
          # will be merged into the root filesystem when building the image.  Use the
          # overlay prepared in /workdir/openwrt/files to include any generated version file.
          [ -d "/workdir/openwrt/files" ] && cp -r "/workdir/openwrt/files" ./files || true
          # Display available profiles for reference.  This helps verify
          # that the expected profile (generic) exists.  Not fatal if omitted.
          make info
          # Build the firmware.  We use PROFILE=generic for x86/64 based on
          # profiles.json, and pass the previously parsed PACKAGE_LIST.  The
          # FILES option injects custom files into the image.
          make image PROFILE=generic PACKAGES="${PACKAGE_LIST}" FILES=files
          echo "COMPILE_STATUS=success" >> $GITHUB_ENV
          # Set device name and timestamp variables for artifact naming.  For
          # x86/64 there is no specific device name, so we use _x86_64.
          echo "DEVICE_NAME=_x86_64" >> $GITHUB_ENV
          echo "FILE_DATE=_$(date +"%Y%m%d%H%M")" >> $GITHUB_ENV

      - name: Check space usage
        if: always()
        run: df -hT

      - name: Organize firmware files
        id: organize
        if: env.UPLOAD_FIRMWARE == 'true' && env.COMPILE_STATUS == 'success'
        run: |
          # For Image Builder, images are stored under bin/targets/<target>/<subtarget>
          cd /workdir/imagebuilder/bin/targets/x86/64
          echo "Firmware directory contents:"
          ls -l
          echo "FIRMWARE=$PWD" >> $GITHUB_ENV
          echo "ORGANIZE_STATUS=success" >> $GITHUB_ENV

      - name: Upload firmware artifacts
        uses: actions/upload-artifact@v4
        if: env.ORGANIZE_STATUS == 'success'
        with:
          name: ImmortalWrt_firmware${{ env.DEVICE_NAME }}${{ env.FILE_DATE }}
          path: ${{ env.FIRMWARE }}/*

      - name: Create release metadata
        if: env.UPLOAD_RELEASE == 'true' && env.COMPILE_STATUS == 'success'
        run: echo "RELEASE_STATUS=success" >> $GITHUB_ENV

      - name: Upload firmware to GitHub Release
        uses: softprops/action-gh-release@v2
        if: env.RELEASE_STATUS == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          files: ${{ env.FIRMWARE }}/*
          body: 'Automated build using Image Builder.'

      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@main
        with:
          token: ${{ github.token }}
          retain_days: 1
          keep_minimum_runs: 3

      - name: Remove old releases
        uses: dev-drprasad/delete-older-releases@master
        if: env.UPLOAD_RELEASE == 'true'
        with:
          keep_latest: 3
          delete_tags: true
        env:
          GITHUB_TOKEN: ${{ github.token }}